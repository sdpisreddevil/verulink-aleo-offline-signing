import credits.aleo;
import token_registry.aleo;

program vlink_council_v03.aleo;

struct TokenMetadata:
    token_id as field;
    name as u128;
    symbol as u128;
    decimals as u8;
    supply as u128;
    max_supply as u128;
    admin as address;
    external_authorization_required as boolean;
    external_authorization_party as address;

struct TokenOwner:
    account as address;
    token_id as field;

struct ProposalVote:
    proposal as field;
    member as address;

struct ProposalVoterKey:
    proposal as field;
    index as u8;

struct AddMember:
    tag as u8;
    id as u32;
    new_member as address;
    new_threshold as u8;

struct RemoveMember:
    tag as u8;
    id as u32;
    existing_member as address;
    new_threshold as u8;

struct Withdrawal:
    tag as u8;
    id as u32;
    token_id as field;
    receiver as address;
    amount as u128;

struct UpdateThreshold:
    tag as u8;
    id as u32;
    new_threshold as u8;

struct ExternalProposal:
    id as u32;
    external_program as address;
    proposal_hash as field;

mapping members:
    key as address.public;
    value as boolean.public;

mapping settings:
    key as boolean.public;
    value as u8.public;

mapping proposals:
    key as u32.public;
    value as field.public;

mapping proposal_vote_counts:
    key as field.public;
    value as u8.public;

mapping proposal_votes:
    key as field.public;
    value as boolean.public;

mapping proposal_voters:
    key as ProposalVoterKey.public;
    value as address.public;

mapping proposal_executed:
    key as field.public;
    value as boolean.public;

mapping proposal_deadline:
    key as field.public;
    value as u32.public;

function initialize:
    input r0 as [address; 5u32].public;
    input r1 as u8.public;
    assert.eq self.caller aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px;
    is.neq r0[0u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r2;
    not r2 into r3;
    is.neq r0[0u32] r0[1u32] into r4;
    or r4 r3 into r5;
    assert.eq r5 true;
    not r2 into r6;
    is.neq r0[0u32] r0[2u32] into r7;
    or r7 r6 into r8;
    assert.eq r8 true;
    not r2 into r9;
    is.neq r0[0u32] r0[3u32] into r10;
    or r10 r9 into r11;
    assert.eq r11 true;
    not r2 into r12;
    is.neq r0[0u32] r0[4u32] into r13;
    or r13 r12 into r14;
    assert.eq r14 true;
    add 0u8 1u8 into r15;
    ternary r2 r15 0u8 into r16;
    is.neq r0[1u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r17;
    not r17 into r18;
    is.neq r0[1u32] r0[2u32] into r19;
    or r19 r18 into r20;
    assert.eq r20 true;
    not r17 into r21;
    is.neq r0[1u32] r0[3u32] into r22;
    or r22 r21 into r23;
    assert.eq r23 true;
    not r17 into r24;
    is.neq r0[1u32] r0[4u32] into r25;
    or r25 r24 into r26;
    assert.eq r26 true;
    add r16 1u8 into r27;
    ternary r17 r27 r16 into r28;
    is.neq r0[2u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r29;
    not r29 into r30;
    is.neq r0[2u32] r0[3u32] into r31;
    or r31 r30 into r32;
    assert.eq r32 true;
    not r29 into r33;
    is.neq r0[2u32] r0[4u32] into r34;
    or r34 r33 into r35;
    assert.eq r35 true;
    add r28 1u8 into r36;
    ternary r29 r36 r28 into r37;
    is.neq r0[3u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r38;
    not r38 into r39;
    is.neq r0[3u32] r0[4u32] into r40;
    or r40 r39 into r41;
    assert.eq r41 true;
    add r37 1u8 into r42;
    ternary r38 r42 r37 into r43;
    is.neq r0[4u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r44;
    add r43 1u8 into r45;
    ternary r44 r45 r43 into r46;
    gt r1 0u8 into r47;
    lte r1 r46 into r48;
    and r47 r48 into r49;
    assert.eq r49 true;
    async initialize r0 r1 r46 into r50;
    output r50 as vlink_council_v03.aleo/initialize.future;

finalize initialize:
    input r0 as [address; 5u32].public;
    input r1 as u8.public;
    input r2 as u8.public;
    contains settings[true] into r3;
    not r3 into r4;
    assert.eq r4 true;
    set true into members[r0[0u32]];
    set true into members[r0[1u32]];
    set true into members[r0[2u32]];
    set true into members[r0[3u32]];
    set true into members[r0[4u32]];
    set true into members[aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc];
    set r1 into settings[true];
    set r2 into settings[false];
    set 0field into proposals[0u32];

function propose:
    input r0 as u32.public;
    input r1 as field.public;
    assert.neq self.caller aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc;
    cast r1 self.caller into r2 as ProposalVote;
    hash.bhp256 r2 into r3 as field;
    cast r1 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r4 as ProposalVote;
    hash.bhp256 r4 into r5 as field;
    async propose self.caller r0 r1 r3 r5 into r6;
    output r6 as vlink_council_v03.aleo/propose.future;

finalize propose:
    input r0 as address.public;
    input r1 as u32.public;
    input r2 as field.public;
    input r3 as field.public;
    input r4 as field.public;
    get members[r0] into r5;
    assert.eq r5 true;
    get proposals[0u32] into r6;
    add r6 1field into r7;
    cast r7 into r8 as u32;
    assert.eq r8 r1;
    add r6 1field into r9;
    set r9 into proposals[0u32];
    set r2 into proposals[r1];
    cast r2 0u8 into r10 as ProposalVoterKey;
    set r0 into proposal_voters[r10];
    contains proposal_vote_counts[r2] into r11;
    not r11 into r12;
    assert.eq r12 true;
    set 1u8 into proposal_vote_counts[r2];
    add block.height 201600u32 into r13;
    set r13 into proposal_deadline[r2];
    set true into proposal_votes[r3];
    set true into proposal_votes[r4];

function vote:
    input r0 as field.public;
    input r1 as boolean.private;
    assert.neq self.caller aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc;
    cast r0 self.caller into r2 as ProposalVote;
    hash.bhp256 r2 into r3 as field;
    async vote self.caller r0 r3 r1 into r4;
    output r4 as vlink_council_v03.aleo/vote.future;

finalize vote:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as boolean.public;
    get members[r0] into r4;
    assert.eq r4 true;
    contains proposal_votes[r2] into r5;
    not r5 into r6;
    assert.eq r6 true;
    contains proposal_executed[r1] into r7;
    not r7 into r8;
    assert.eq r8 true;
    get proposal_deadline[r1] into r9;
    lt block.height r9 into r10;
    assert.eq r10 true;
    get proposal_vote_counts[r1] into r11;
    cast r1 r11 into r12 as ProposalVoterKey;
    set r0 into proposal_voters[r12];
    set r3 into proposal_votes[r2];
    add r11 1u8 into r13;
    set r13 into proposal_vote_counts[r1];

function add_member:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as u8.public;
    input r3 as [address; 5u32].public;
    gt r2 0u8 into r4;
    assert.eq r4 true;
    cast 1u8 r0 r1 r2 into r5 as AddMember;
    hash.bhp256 r5 into r6 as field;
    is.neq r3[0u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r7;
    not r7 into r8;
    is.neq r3[0u32] r3[1u32] into r9;
    or r9 r8 into r10;
    assert.eq r10 true;
    not r7 into r11;
    is.neq r3[0u32] r3[2u32] into r12;
    or r12 r11 into r13;
    assert.eq r13 true;
    not r7 into r14;
    is.neq r3[0u32] r3[3u32] into r15;
    or r15 r14 into r16;
    assert.eq r16 true;
    not r7 into r17;
    is.neq r3[0u32] r3[4u32] into r18;
    or r18 r17 into r19;
    assert.eq r19 true;
    add 0u8 1u8 into r20;
    ternary r7 r20 0u8 into r21;
    is.neq r3[1u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r22;
    not r22 into r23;
    is.neq r3[1u32] r3[2u32] into r24;
    or r24 r23 into r25;
    assert.eq r25 true;
    not r22 into r26;
    is.neq r3[1u32] r3[3u32] into r27;
    or r27 r26 into r28;
    assert.eq r28 true;
    not r22 into r29;
    is.neq r3[1u32] r3[4u32] into r30;
    or r30 r29 into r31;
    assert.eq r31 true;
    add r21 1u8 into r32;
    ternary r22 r32 r21 into r33;
    is.neq r3[2u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r34;
    not r34 into r35;
    is.neq r3[2u32] r3[3u32] into r36;
    or r36 r35 into r37;
    assert.eq r37 true;
    not r34 into r38;
    is.neq r3[2u32] r3[4u32] into r39;
    or r39 r38 into r40;
    assert.eq r40 true;
    add r33 1u8 into r41;
    ternary r34 r41 r33 into r42;
    is.neq r3[3u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r43;
    not r43 into r44;
    is.neq r3[3u32] r3[4u32] into r45;
    or r45 r44 into r46;
    assert.eq r46 true;
    add r42 1u8 into r47;
    ternary r43 r47 r42 into r48;
    is.neq r3[4u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r49;
    add r48 1u8 into r50;
    ternary r49 r50 r48 into r51;
    cast r6 r3[0u32] into r52 as ProposalVote;
    hash.bhp256 r52 into r53 as field;
    cast r6 r3[1u32] into r54 as ProposalVote;
    hash.bhp256 r54 into r55 as field;
    cast r6 r3[2u32] into r56 as ProposalVote;
    hash.bhp256 r56 into r57 as field;
    cast r6 r3[3u32] into r58 as ProposalVote;
    hash.bhp256 r58 into r59 as field;
    cast r6 r3[4u32] into r60 as ProposalVote;
    hash.bhp256 r60 into r61 as field;
    cast r53 r55 r57 r59 r61 into r62 as [field; 5u32];
    async add_member r6 r1 r2 r3 r62 r51 into r63;
    output r63 as vlink_council_v03.aleo/add_member.future;

finalize add_member:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u8.public;
    input r3 as [address; 5u32].public;
    input r4 as [field; 5u32].public;
    input r5 as u8.public;
    get settings[false] into r6;
    lte r2 r6 into r7;
    assert.eq r7 true;
    add r6 1u8 into r8;
    lte r8 5u8 into r9;
    assert.eq r9 true;
    contains members[r3[0u32]] into r10;
    assert.eq r10 true;
    get proposal_votes[r4[0u32]] into r11;
    assert.eq r11 true;
    contains members[r3[1u32]] into r12;
    assert.eq r12 true;
    get proposal_votes[r4[1u32]] into r13;
    assert.eq r13 true;
    contains members[r3[2u32]] into r14;
    assert.eq r14 true;
    get proposal_votes[r4[2u32]] into r15;
    assert.eq r15 true;
    contains members[r3[3u32]] into r16;
    assert.eq r16 true;
    get proposal_votes[r4[3u32]] into r17;
    assert.eq r17 true;
    contains members[r3[4u32]] into r18;
    assert.eq r18 true;
    get proposal_votes[r4[4u32]] into r19;
    assert.eq r19 true;
    get settings[true] into r20;
    gte r5 r20 into r21;
    assert.eq r21 true;
    contains proposal_executed[r0] into r22;
    not r22 into r23;
    assert.eq r23 true;
    get proposal_deadline[r0] into r24;
    lt block.height r24 into r25;
    assert.eq r25 true;
    set true into proposal_executed[r0];
    contains members[r1] into r26;
    not r26 into r27;
    assert.eq r27 true;
    set true into members[r1];
    set r2 into settings[true];
    add r6 1u8 into r28;
    lte r28 5u8 into r29;
    assert.eq r29 true;
    add r6 1u8 into r30;
    set r30 into settings[false];

function remove_member:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as u8.public;
    input r3 as [address; 5u32].public;
    assert.neq r1 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc;
    gt r2 0u8 into r4;
    assert.eq r4 true;
    cast 2u8 r0 r1 r2 into r5 as RemoveMember;
    hash.bhp256 r5 into r6 as field;
    is.neq r3[0u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r7;
    not r7 into r8;
    is.neq r3[0u32] r3[1u32] into r9;
    or r9 r8 into r10;
    assert.eq r10 true;
    not r7 into r11;
    is.neq r3[0u32] r3[2u32] into r12;
    or r12 r11 into r13;
    assert.eq r13 true;
    not r7 into r14;
    is.neq r3[0u32] r3[3u32] into r15;
    or r15 r14 into r16;
    assert.eq r16 true;
    not r7 into r17;
    is.neq r3[0u32] r3[4u32] into r18;
    or r18 r17 into r19;
    assert.eq r19 true;
    add 0u8 1u8 into r20;
    ternary r7 r20 0u8 into r21;
    is.neq r3[1u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r22;
    not r22 into r23;
    is.neq r3[1u32] r3[2u32] into r24;
    or r24 r23 into r25;
    assert.eq r25 true;
    not r22 into r26;
    is.neq r3[1u32] r3[3u32] into r27;
    or r27 r26 into r28;
    assert.eq r28 true;
    not r22 into r29;
    is.neq r3[1u32] r3[4u32] into r30;
    or r30 r29 into r31;
    assert.eq r31 true;
    add r21 1u8 into r32;
    ternary r22 r32 r21 into r33;
    is.neq r3[2u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r34;
    not r34 into r35;
    is.neq r3[2u32] r3[3u32] into r36;
    or r36 r35 into r37;
    assert.eq r37 true;
    not r34 into r38;
    is.neq r3[2u32] r3[4u32] into r39;
    or r39 r38 into r40;
    assert.eq r40 true;
    add r33 1u8 into r41;
    ternary r34 r41 r33 into r42;
    is.neq r3[3u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r43;
    not r43 into r44;
    is.neq r3[3u32] r3[4u32] into r45;
    or r45 r44 into r46;
    assert.eq r46 true;
    add r42 1u8 into r47;
    ternary r43 r47 r42 into r48;
    is.neq r3[4u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r49;
    add r48 1u8 into r50;
    ternary r49 r50 r48 into r51;
    cast r6 r3[0u32] into r52 as ProposalVote;
    hash.bhp256 r52 into r53 as field;
    cast r6 r3[1u32] into r54 as ProposalVote;
    hash.bhp256 r54 into r55 as field;
    cast r6 r3[2u32] into r56 as ProposalVote;
    hash.bhp256 r56 into r57 as field;
    cast r6 r3[3u32] into r58 as ProposalVote;
    hash.bhp256 r58 into r59 as field;
    cast r6 r3[4u32] into r60 as ProposalVote;
    hash.bhp256 r60 into r61 as field;
    cast r53 r55 r57 r59 r61 into r62 as [field; 5u32];
    async remove_member r6 r1 r2 r3 r62 r51 into r63;
    output r63 as vlink_council_v03.aleo/remove_member.future;

finalize remove_member:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u8.public;
    input r3 as [address; 5u32].public;
    input r4 as [field; 5u32].public;
    input r5 as u8.public;
    contains members[r3[0u32]] into r6;
    assert.eq r6 true;
    get proposal_votes[r4[0u32]] into r7;
    assert.eq r7 true;
    contains members[r3[1u32]] into r8;
    assert.eq r8 true;
    get proposal_votes[r4[1u32]] into r9;
    assert.eq r9 true;
    contains members[r3[2u32]] into r10;
    assert.eq r10 true;
    get proposal_votes[r4[2u32]] into r11;
    assert.eq r11 true;
    contains members[r3[3u32]] into r12;
    assert.eq r12 true;
    get proposal_votes[r4[3u32]] into r13;
    assert.eq r13 true;
    contains members[r3[4u32]] into r14;
    assert.eq r14 true;
    get proposal_votes[r4[4u32]] into r15;
    assert.eq r15 true;
    get settings[true] into r16;
    gte r5 r16 into r17;
    assert.eq r17 true;
    get proposal_deadline[r0] into r18;
    lt block.height r18 into r19;
    assert.eq r19 true;
    contains proposal_executed[r0] into r20;
    not r20 into r21;
    assert.eq r21 true;
    get proposal_deadline[r0] into r22;
    lt block.height r22 into r23;
    assert.eq r23 true;
    set true into proposal_executed[r0];
    get settings[false] into r24;
    gt r24 1u8 into r25;
    assert.eq r25 true;
    lt r2 r24 into r26;
    assert.eq r26 true;
    contains members[r1] into r27;
    assert.eq r27 true;
    remove members[r1];
    set r2 into settings[true];
    sub r24 1u8 into r28;
    set r28 into settings[false];

function withdraw_fees:
    input r0 as u32.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    input r4 as [address; 5u32].public;
    gt r3 0u128 into r5;
    assert.eq r5 true;
    cast 3u8 r0 r1 r2 r3 into r6 as Withdrawal;
    hash.bhp256 r6 into r7 as field;
    is.neq r4[0u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r8;
    not r8 into r9;
    is.neq r4[0u32] r4[1u32] into r10;
    or r10 r9 into r11;
    assert.eq r11 true;
    not r8 into r12;
    is.neq r4[0u32] r4[2u32] into r13;
    or r13 r12 into r14;
    assert.eq r14 true;
    not r8 into r15;
    is.neq r4[0u32] r4[3u32] into r16;
    or r16 r15 into r17;
    assert.eq r17 true;
    not r8 into r18;
    is.neq r4[0u32] r4[4u32] into r19;
    or r19 r18 into r20;
    assert.eq r20 true;
    add 0u8 1u8 into r21;
    ternary r8 r21 0u8 into r22;
    is.neq r4[1u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r23;
    not r23 into r24;
    is.neq r4[1u32] r4[2u32] into r25;
    or r25 r24 into r26;
    assert.eq r26 true;
    not r23 into r27;
    is.neq r4[1u32] r4[3u32] into r28;
    or r28 r27 into r29;
    assert.eq r29 true;
    not r23 into r30;
    is.neq r4[1u32] r4[4u32] into r31;
    or r31 r30 into r32;
    assert.eq r32 true;
    add r22 1u8 into r33;
    ternary r23 r33 r22 into r34;
    is.neq r4[2u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r35;
    not r35 into r36;
    is.neq r4[2u32] r4[3u32] into r37;
    or r37 r36 into r38;
    assert.eq r38 true;
    not r35 into r39;
    is.neq r4[2u32] r4[4u32] into r40;
    or r40 r39 into r41;
    assert.eq r41 true;
    add r34 1u8 into r42;
    ternary r35 r42 r34 into r43;
    is.neq r4[3u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r44;
    not r44 into r45;
    is.neq r4[3u32] r4[4u32] into r46;
    or r46 r45 into r47;
    assert.eq r47 true;
    add r43 1u8 into r48;
    ternary r44 r48 r43 into r49;
    is.neq r4[4u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r50;
    add r49 1u8 into r51;
    ternary r50 r51 r49 into r52;
    cast r7 r4[0u32] into r53 as ProposalVote;
    hash.bhp256 r53 into r54 as field;
    cast r7 r4[1u32] into r55 as ProposalVote;
    hash.bhp256 r55 into r56 as field;
    cast r7 r4[2u32] into r57 as ProposalVote;
    hash.bhp256 r57 into r58 as field;
    cast r7 r4[3u32] into r59 as ProposalVote;
    hash.bhp256 r59 into r60 as field;
    cast r7 r4[4u32] into r61 as ProposalVote;
    hash.bhp256 r61 into r62 as field;
    cast r54 r56 r58 r60 r62 into r63 as [field; 5u32];
    call token_registry.aleo/transfer_public r1 r2 r3 into r64;
    async withdraw_fees r7 r3 r4 r63 r52 r64 into r65;
    output r65 as vlink_council_v03.aleo/withdraw_fees.future;

finalize withdraw_fees:
    input r0 as field.public;
    input r1 as u128.public;
    input r2 as [address; 5u32].public;
    input r3 as [field; 5u32].public;
    input r4 as u8.public;
    input r5 as token_registry.aleo/transfer_public.future;
    await r5;
    contains members[r2[0u32]] into r6;
    assert.eq r6 true;
    get proposal_votes[r3[0u32]] into r7;
    assert.eq r7 true;
    contains members[r2[1u32]] into r8;
    assert.eq r8 true;
    get proposal_votes[r3[1u32]] into r9;
    assert.eq r9 true;
    contains members[r2[2u32]] into r10;
    assert.eq r10 true;
    get proposal_votes[r3[2u32]] into r11;
    assert.eq r11 true;
    contains members[r2[3u32]] into r12;
    assert.eq r12 true;
    get proposal_votes[r3[3u32]] into r13;
    assert.eq r13 true;
    contains members[r2[4u32]] into r14;
    assert.eq r14 true;
    get proposal_votes[r3[4u32]] into r15;
    assert.eq r15 true;
    get proposal_deadline[r0] into r16;
    lt block.height r16 into r17;
    assert.eq r17 true;
    get settings[true] into r18;
    gte r4 r18 into r19;
    assert.eq r19 true;
    get proposal_deadline[r0] into r20;
    lt block.height r20 into r21;
    assert.eq r21 true;
    contains proposal_executed[r0] into r22;
    not r22 into r23;
    assert.eq r23 true;
    set true into proposal_executed[r0];

function update_threshold:
    input r0 as u32.public;
    input r1 as u8.public;
    input r2 as [address; 5u32].public;
    gt r1 0u8 into r3;
    assert.eq r3 true;
    cast 4u8 r0 r1 into r4 as UpdateThreshold;
    hash.bhp256 r4 into r5 as field;
    is.neq r2[0u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r6;
    not r6 into r7;
    is.neq r2[0u32] r2[1u32] into r8;
    or r8 r7 into r9;
    assert.eq r9 true;
    not r6 into r10;
    is.neq r2[0u32] r2[2u32] into r11;
    or r11 r10 into r12;
    assert.eq r12 true;
    not r6 into r13;
    is.neq r2[0u32] r2[3u32] into r14;
    or r14 r13 into r15;
    assert.eq r15 true;
    not r6 into r16;
    is.neq r2[0u32] r2[4u32] into r17;
    or r17 r16 into r18;
    assert.eq r18 true;
    add 0u8 1u8 into r19;
    ternary r6 r19 0u8 into r20;
    is.neq r2[1u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r21;
    not r21 into r22;
    is.neq r2[1u32] r2[2u32] into r23;
    or r23 r22 into r24;
    assert.eq r24 true;
    not r21 into r25;
    is.neq r2[1u32] r2[3u32] into r26;
    or r26 r25 into r27;
    assert.eq r27 true;
    not r21 into r28;
    is.neq r2[1u32] r2[4u32] into r29;
    or r29 r28 into r30;
    assert.eq r30 true;
    add r20 1u8 into r31;
    ternary r21 r31 r20 into r32;
    is.neq r2[2u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r33;
    not r33 into r34;
    is.neq r2[2u32] r2[3u32] into r35;
    or r35 r34 into r36;
    assert.eq r36 true;
    not r33 into r37;
    is.neq r2[2u32] r2[4u32] into r38;
    or r38 r37 into r39;
    assert.eq r39 true;
    add r32 1u8 into r40;
    ternary r33 r40 r32 into r41;
    is.neq r2[3u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r42;
    not r42 into r43;
    is.neq r2[3u32] r2[4u32] into r44;
    or r44 r43 into r45;
    assert.eq r45 true;
    add r41 1u8 into r46;
    ternary r42 r46 r41 into r47;
    is.neq r2[4u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r48;
    add r47 1u8 into r49;
    ternary r48 r49 r47 into r50;
    cast r5 r2[0u32] into r51 as ProposalVote;
    hash.bhp256 r51 into r52 as field;
    cast r5 r2[1u32] into r53 as ProposalVote;
    hash.bhp256 r53 into r54 as field;
    cast r5 r2[2u32] into r55 as ProposalVote;
    hash.bhp256 r55 into r56 as field;
    cast r5 r2[3u32] into r57 as ProposalVote;
    hash.bhp256 r57 into r58 as field;
    cast r5 r2[4u32] into r59 as ProposalVote;
    hash.bhp256 r59 into r60 as field;
    cast r52 r54 r56 r58 r60 into r61 as [field; 5u32];
    async update_threshold r5 r1 r2 r61 r50 into r62;
    output r62 as vlink_council_v03.aleo/update_threshold.future;

finalize update_threshold:
    input r0 as field.public;
    input r1 as u8.public;
    input r2 as [address; 5u32].public;
    input r3 as [field; 5u32].public;
    input r4 as u8.public;
    contains members[r2[0u32]] into r5;
    assert.eq r5 true;
    get proposal_votes[r3[0u32]] into r6;
    assert.eq r6 true;
    contains members[r2[1u32]] into r7;
    assert.eq r7 true;
    get proposal_votes[r3[1u32]] into r8;
    assert.eq r8 true;
    contains members[r2[2u32]] into r9;
    assert.eq r9 true;
    get proposal_votes[r3[2u32]] into r10;
    assert.eq r10 true;
    contains members[r2[3u32]] into r11;
    assert.eq r11 true;
    get proposal_votes[r3[3u32]] into r12;
    assert.eq r12 true;
    contains members[r2[4u32]] into r13;
    assert.eq r13 true;
    get proposal_votes[r3[4u32]] into r14;
    assert.eq r14 true;
    get proposal_deadline[r0] into r15;
    lt block.height r15 into r16;
    assert.eq r16 true;
    get settings[true] into r17;
    get settings[false] into r18;
    lte r1 r18 into r19;
    assert.eq r19 true;
    gte r4 r17 into r20;
    assert.eq r20 true;
    get proposal_deadline[r0] into r21;
    lt block.height r21 into r22;
    assert.eq r22 true;
    contains proposal_executed[r0] into r23;
    not r23 into r24;
    assert.eq r24 true;
    set true into proposal_executed[r0];
    set r1 into settings[true];

function external_execute:
    input r0 as u32.public;
    input r1 as field.public;
    input r2 as [address; 5u32].public;
    cast r0 self.caller r1 into r3 as ExternalProposal;
    hash.bhp256 r3 into r4 as field;
    is.neq r2[0u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r5;
    not r5 into r6;
    is.neq r2[0u32] r2[1u32] into r7;
    or r7 r6 into r8;
    assert.eq r8 true;
    not r5 into r9;
    is.neq r2[0u32] r2[2u32] into r10;
    or r10 r9 into r11;
    assert.eq r11 true;
    not r5 into r12;
    is.neq r2[0u32] r2[3u32] into r13;
    or r13 r12 into r14;
    assert.eq r14 true;
    not r5 into r15;
    is.neq r2[0u32] r2[4u32] into r16;
    or r16 r15 into r17;
    assert.eq r17 true;
    add 0u8 1u8 into r18;
    ternary r5 r18 0u8 into r19;
    is.neq r2[1u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r20;
    not r20 into r21;
    is.neq r2[1u32] r2[2u32] into r22;
    or r22 r21 into r23;
    assert.eq r23 true;
    not r20 into r24;
    is.neq r2[1u32] r2[3u32] into r25;
    or r25 r24 into r26;
    assert.eq r26 true;
    not r20 into r27;
    is.neq r2[1u32] r2[4u32] into r28;
    or r28 r27 into r29;
    assert.eq r29 true;
    add r19 1u8 into r30;
    ternary r20 r30 r19 into r31;
    is.neq r2[2u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r32;
    not r32 into r33;
    is.neq r2[2u32] r2[3u32] into r34;
    or r34 r33 into r35;
    assert.eq r35 true;
    not r32 into r36;
    is.neq r2[2u32] r2[4u32] into r37;
    or r37 r36 into r38;
    assert.eq r38 true;
    add r31 1u8 into r39;
    ternary r32 r39 r31 into r40;
    is.neq r2[3u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r41;
    not r41 into r42;
    is.neq r2[3u32] r2[4u32] into r43;
    or r43 r42 into r44;
    assert.eq r44 true;
    add r40 1u8 into r45;
    ternary r41 r45 r40 into r46;
    is.neq r2[4u32] aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r47;
    add r46 1u8 into r48;
    ternary r47 r48 r46 into r49;
    cast r4 r2[0u32] into r50 as ProposalVote;
    hash.bhp256 r50 into r51 as field;
    cast r4 r2[1u32] into r52 as ProposalVote;
    hash.bhp256 r52 into r53 as field;
    cast r4 r2[2u32] into r54 as ProposalVote;
    hash.bhp256 r54 into r55 as field;
    cast r4 r2[3u32] into r56 as ProposalVote;
    hash.bhp256 r56 into r57 as field;
    cast r4 r2[4u32] into r58 as ProposalVote;
    hash.bhp256 r58 into r59 as field;
    cast r51 r53 r55 r57 r59 into r60 as [field; 5u32];
    async external_execute r4 r2 r60 r49 self.caller into r61;
    output r61 as vlink_council_v03.aleo/external_execute.future;

finalize external_execute:
    input r0 as field.public;
    input r1 as [address; 5u32].public;
    input r2 as [field; 5u32].public;
    input r3 as u8.public;
    input r4 as address.public;
    get proposal_deadline[r0] into r5;
    lt block.height r5 into r6;
    assert.eq r6 true;
    contains members[r1[0u32]] into r7;
    assert.eq r7 true;
    get proposal_votes[r2[0u32]] into r8;
    assert.eq r8 true;
    contains members[r1[1u32]] into r9;
    assert.eq r9 true;
    get proposal_votes[r2[1u32]] into r10;
    assert.eq r10 true;
    contains members[r1[2u32]] into r11;
    assert.eq r11 true;
    get proposal_votes[r2[2u32]] into r12;
    assert.eq r12 true;
    contains members[r1[3u32]] into r13;
    assert.eq r13 true;
    get proposal_votes[r2[3u32]] into r14;
    assert.eq r14 true;
    contains members[r1[4u32]] into r15;
    assert.eq r15 true;
    get proposal_votes[r2[4u32]] into r16;
    assert.eq r16 true;
    get settings[true] into r17;
    gte r3 r17 into r18;
    assert.eq r18 true;
    contains proposal_executed[r0] into r19;
    not r19 into r20;
    assert.eq r20 true;
    set true into proposal_executed[r0];

constructor:
    assert.eq edition 0u16;
